#!/bin/bash

function g_files_modified_by() {
  local name="$1"
  git log --pretty="%H" --author=$name | while read commit_hash; do git show --oneline --name-only $commit_hash | tail -n+2; done | sort | uniq
}

function g_actual_branch() {
  git branch | sed -n '/\* /s///p'
}

function g_purge_branch() {
  git branch -D "${1}" && git push --delete origin "${1}"
}

function g_dir_assume_unchaged() {
  git update-index --assume-unchanged $(git ls-files | tr '\n' ' ')
}

function g_dir_no_assume_unchaged() {
  git update-index --no-assume-unchanged $(git ls-files | tr '\n' ' ')
}

function gpull() {
  # First remove the color codes from the git branch output and then stract the branch name
  local branch=$(git branch | git branch | sed -e 's/\x1b\[[0-9;]*m//g' | sed -En 's/\*[[:space:]](\[[0-9]*\][[:space:]][[:space:]]?)(.*)/\2/p')
  info "Pulling from origin $branch"
  git pull origin $branch
}

function gpush() {
  # First remove the color codes from the git branch output and then stract the branch name
  local branch=$(git branch | git branch | sed -e 's/\x1b\[[0-9;]*m//g' | sed -En 's/\*[[:space:]](\[[0-9]*\][[:space:]][[:space:]]?)(.*)/\2/p')
  info "Pushing to origin $branch"
  git push --recurse-submodules=on-demand origin $branch
}

function gpushf() {
  # First remove the color codes from the git branch output and then stract the branch name
  local branch=$(git branch | git branch | sed -e 's/\x1b\[[0-9;]*m//g' | sed -En 's/\*[[:space:]](\[[0-9]*\][[:space:]][[:space:]]?)(.*)/\2/p')
  info "Pushing to origin $branch"
  git push -f origin $branch
}

function gstash() {
  g stash apply && g stash drop
}

function gcheckout() {
  g fetch origin "${1}" && g checkout "${1}"
}

function g_cf() {

  if [[ "$2" == "js" ]]; then
    git checkout react/GMDJS-$1
  else
    git checkout feature/GM-$1
  fi
}

function g_ch() {

  if [[ "$2" == "js" ]]; then
    git checkout hotfix/GMDJS-$1
  else
    git checkout hotfix/GM-$1
  fi
}

function gsync() {

  info "Adding all files to index"
  git add .

  info "Committing files indexed"
  git commit -m "$(date +"%a %-d of %b of %Y at %X")"

  info "Syncing local changes with remote changes"
  gpull
  gpush
}

function gh_branches() {

  local user
  local project

  info "Type the user:"
  read user

  info "Type the project: "
  read project

  open https://github.com/$user/$project/branches
}

function gh_branches_compare() {

  local user
  local project
  local branch

  info "Type the user:"
  read user

  info "Type the project"
  read project

  info "Type the branch"
  read branch

  open https://github.com/$user/$project/compare/$branch
}

function gh_branches_compare_range() {

  local user
  local project
  local first_branch
  local second_branch

  info "Type the project"
  read project

  info "Type the first branch:"
  read first_branch

  info "Type the second branch:"
  read second_branch

  open https://github.com/allergan-data-labs/$project/compare/$first_branch...$second_branch
}

function gh_compare() {
  local project_name=$(git config --local remote.origin.url | sed -n 's#.*/\([^.]*\)\.git#\1#p')
  local branch=$(git branch | git branch | sed -e 's/\x1b\[[0-9;]*m//g' | sed -En 's/\*[[:space:]](\[[0-9]*\][[:space:]][[:space:]]?)(.*)/\2/p')

  info "Comparing main with $branch"
  open https://github.com/allergan-data-labs/$project_name/compare/main...$branch
}

function gh_commits() {

  local user
  local project
  local branch
  local author

  info 'Type the user:'
  read user

  info 'Type the project:'
  read project

  info 'Type the branch:'
  read branch

  info 'Type the author:'
  read author

  open https://github.com/$user/$project/commits/$branch\?author\=$author
}

g_assume_unchaged() {
  g update-index --assume-unchanged $1
}

g_no_assume_unchaged() {
  g update-index --no-assume-unchanged $1
}

g_list_unchaged_files() {
  git ls-files -v | grep -E "^[a-z]"
}

g_restore_file() {
  local commit_hash=$1
  local file_path=$2

  if [[ -z $commit_hash ]]; then
    error "You must provide a commit hash as first argument"
    return 1
  fi
  if [[ -z $file_path ]]; then
    error "You must provide a file path as second argument"
    return 1
  fi

  g checkout ${commit_hash}^ -- ${file_path}
}

gcheckout() {
  git fetch origin $1 && git checkout $1
}

# ---------------------------------------------------------
# Git Worktree Automator
# Usage: gwnew <branch-name> [base-branch]
# ---------------------------------------------------------
function gwnew() {
  if [ -z "$1" ]; then
    error "‚ùå Error: Please provide a branch name."
    info "Usage: gwnew <new-branch-name> [base-branch]"
    return 1
  fi

  local BRANCH_NAME=$1
  local BASE_BRANCH=${2:-HEAD} # Default to HEAD if no base provided

  # 1. Get the root of the current repository
  local REPO_ROOT
  REPO_ROOT=$(git rev-parse --show-toplevel)

  # 2. Define the sibling directory path
  # This puts the new folder next to your current repo, not inside it.
  local NEW_DIR="$(dirname "$REPO_ROOT")/$BRANCH_NAME"

  info "üå≤ Creating worktree at: $NEW_DIR"

  # 3. Create the worktree
  # We try to checkout the branch; if it doesn't exist, we create it (-b)
  if git rev-parse --verify "$BRANCH_NAME" >/dev/null 2>&1; then
    git worktree add "$NEW_DIR" "$BRANCH_NAME"
  else
    git worktree add -b "$BRANCH_NAME" "$NEW_DIR" "$BASE_BRANCH"
  fi

  # 4. Smart Copy node_modules
  # We use rsync if available (faster/progress bar), otherwise cp
  if [ -d "$REPO_ROOT/node_modules" ]; then
    info "üì¶ node_modules detected. Copying to new tree..."
    if command -v rsync &>/dev/null; then
      # The trailing slash on src/ is important for rsync
      rsync -a --info=progress2 "$REPO_ROOT/node_modules/" "$NEW_DIR/node_modules"
    else
      cp -r "$REPO_ROOT/node_modules" "$NEW_DIR/"
    fi
    success "‚úÖ Dependencies copied."
  fi

  # 5. Switch to the new directory
  cd "$NEW_DIR" || return
  success "üöÄ You are now in: $NEW_DIR"
}

# ---------------------------------------------------------
# Git Worktree Cleanup
# Usage: gwrm <folder-name>
# ---------------------------------------------------------
function gwrm() {
  if [ -z "$1" ]; then
    error "‚ùå Error: Please provide the folder name to remove."
    return 1
  fi

  local TARGET_NAME=$1

  # 1. Get the Repo Root and Parent Dir
  local REPO_ROOT
  REPO_ROOT=$(git rev-parse --show-toplevel)
  local PARENT_DIR
  PARENT_DIR=$(dirname "$REPO_ROOT")
  local TARGET_PATH="$PARENT_DIR/$TARGET_NAME"

  # 2. Safety Checks
  # Ensure we aren't trying to delete the current folder we are standing in
  if [ "$TARGET_PATH" == "$PWD" ]; then
    error "‚ùå Error: You are currently inside the folder you want to delete."
    info "   Please cd to the main repository first."
    return 1
  fi

  # Ensure the target actually exists
  if [ ! -d "$TARGET_PATH" ]; then
    error "‚ùå Error: Directory '$TARGET_PATH' does not exist."
    return 1
  fi

  info "üóëÔ∏è  Removing worktree at: $TARGET_PATH"

  # 3. Remove the worktree
  # This removes the entry from .git/worktrees AND deletes the folder
  # We use --force just in case the worktree has ignored files or untracked changes
  # that usually block deletion (remove --force if you want strictly safe mode)
  git worktree remove "$TARGET_PATH"

  # 4. Prune (Housekeeping)
  # Cleans up any stale references in .git/worktrees
  git worktree prune

  success "‚úÖ Worktree removed and connections pruned."
}
